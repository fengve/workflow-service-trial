// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: identity_integration.sql

package lib

import (
	"context"
	"encoding/json"
)

const CreateIntegration = `-- name: CreateIntegration :one
INSERT INTO identity.integration (organization_id, partner, service, status, info, created_by, last_updated_by)
    VALUES ($1, $2, $3, $4, $5, $6, $6) RETURNING organization_id, partner, service, status, info, creation_time, created_by, last_update_time, last_updated_by
`

type CreateIntegrationParams struct {
	OrganizationID string          `db:"organization_id" json:"organizationID"`
	Partner        string          `db:"partner" json:"partner"`
	Service        string          `db:"service" json:"service"`
	Status         string          `db:"status" json:"status"`
	Info           json.RawMessage `db:"info" json:"info"`
	CreatedBy      string          `db:"created_by" json:"createdBy"`
}

func (q *Queries) CreateIntegration(ctx context.Context, arg CreateIntegrationParams) (IdentityIntegration, error) {
	row := q.db.QueryRowContext(ctx, CreateIntegration,
		arg.OrganizationID,
		arg.Partner,
		arg.Service,
		arg.Status,
		arg.Info,
		arg.CreatedBy,
	)
	var i IdentityIntegration
	err := row.Scan(
		&i.OrganizationID,
		&i.Partner,
		&i.Service,
		&i.Status,
		&i.Info,
		&i.CreationTime,
		&i.CreatedBy,
		&i.LastUpdateTime,
		&i.LastUpdatedBy,
	)
	return i, err
}

const DeleteIntegration = `-- name: DeleteIntegration :exec
DELETE FROM identity.integration WHERE organization_id = $1 AND partner = $2 AND service = $3
`

type DeleteIntegrationParams struct {
	OrganizationID string `db:"organization_id" json:"organizationID"`
	Partner        string `db:"partner" json:"partner"`
	Service        string `db:"service" json:"service"`
}

func (q *Queries) DeleteIntegration(ctx context.Context, arg DeleteIntegrationParams) error {
	_, err := q.db.ExecContext(ctx, DeleteIntegration, arg.OrganizationID, arg.Partner, arg.Service)
	return err
}

const GetHubspotIntegrationByPortalId = `-- name: GetHubspotIntegrationByPortalId :many
SELECT organization_id, partner, service, status, info, creation_time, created_by, last_update_time, last_updated_by FROM identity.integration WHERE partner = 'HUBSPOT' AND service = 'CRM' AND info->'hubspotCrmIntegration'->>'portalId' = $1
`

func (q *Queries) GetHubspotIntegrationByPortalId(ctx context.Context, portalID json.RawMessage) ([]IdentityIntegration, error) {
	rows, err := q.db.QueryContext(ctx, GetHubspotIntegrationByPortalId, portalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IdentityIntegration{}
	for rows.Next() {
		var i IdentityIntegration
		if err := rows.Scan(
			&i.OrganizationID,
			&i.Partner,
			&i.Service,
			&i.Status,
			&i.Info,
			&i.CreationTime,
			&i.CreatedBy,
			&i.LastUpdateTime,
			&i.LastUpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetIntegration = `-- name: GetIntegration :one
SELECT organization_id, partner, service, status, info, creation_time, created_by, last_update_time, last_updated_by FROM identity.integration WHERE organization_id = $1 AND partner = $2 AND service = $3 LIMIT 1
`

type GetIntegrationParams struct {
	OrganizationID string `db:"organization_id" json:"organizationID"`
	Partner        string `db:"partner" json:"partner"`
	Service        string `db:"service" json:"service"`
}

func (q *Queries) GetIntegration(ctx context.Context, arg GetIntegrationParams) (IdentityIntegration, error) {
	row := q.db.QueryRowContext(ctx, GetIntegration, arg.OrganizationID, arg.Partner, arg.Service)
	var i IdentityIntegration
	err := row.Scan(
		&i.OrganizationID,
		&i.Partner,
		&i.Service,
		&i.Status,
		&i.Info,
		&i.CreationTime,
		&i.CreatedBy,
		&i.LastUpdateTime,
		&i.LastUpdatedBy,
	)
	return i, err
}

const ListAzureIntegrationsByPublisherId = `-- name: ListAzureIntegrationsByPublisherId :many
SELECT organization_id, partner, service, status, info, creation_time, created_by, last_update_time, last_updated_by FROM identity.integration WHERE partner = 'AZURE' AND info->'azureIntegration'->>'publisherID' = $1
`

func (q *Queries) ListAzureIntegrationsByPublisherId(ctx context.Context, publisherID json.RawMessage) ([]IdentityIntegration, error) {
	rows, err := q.db.QueryContext(ctx, ListAzureIntegrationsByPublisherId, publisherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IdentityIntegration{}
	for rows.Next() {
		var i IdentityIntegration
		if err := rows.Scan(
			&i.OrganizationID,
			&i.Partner,
			&i.Service,
			&i.Status,
			&i.Info,
			&i.CreationTime,
			&i.CreatedBy,
			&i.LastUpdateTime,
			&i.LastUpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListGcpIntegrationsByProjectNumber = `-- name: ListGcpIntegrationsByProjectNumber :many
SELECT organization_id, partner, service, status, info, creation_time, created_by, last_update_time, last_updated_by FROM identity.integration WHERE partner = 'GCP' AND info->'gcpIntegration'->>'gcpProjectNumber' = $1::text
`

func (q *Queries) ListGcpIntegrationsByProjectNumber(ctx context.Context, projectNumber string) ([]IdentityIntegration, error) {
	rows, err := q.db.QueryContext(ctx, ListGcpIntegrationsByProjectNumber, projectNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IdentityIntegration{}
	for rows.Next() {
		var i IdentityIntegration
		if err := rows.Scan(
			&i.OrganizationID,
			&i.Partner,
			&i.Service,
			&i.Status,
			&i.Info,
			&i.CreationTime,
			&i.CreatedBy,
			&i.LastUpdateTime,
			&i.LastUpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListIntegrations = `-- name: ListIntegrations :many
SELECT organization_id, partner, service, status, info, creation_time, created_by, last_update_time, last_updated_by FROM identity.integration WHERE organization_id = $1 ORDER BY creation_time
`

func (q *Queries) ListIntegrations(ctx context.Context, organizationID string) ([]IdentityIntegration, error) {
	rows, err := q.db.QueryContext(ctx, ListIntegrations, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IdentityIntegration{}
	for rows.Next() {
		var i IdentityIntegration
		if err := rows.Scan(
			&i.OrganizationID,
			&i.Partner,
			&i.Service,
			&i.Status,
			&i.Info,
			&i.CreationTime,
			&i.CreatedBy,
			&i.LastUpdateTime,
			&i.LastUpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListIntegrationsByPartnerServiceAndStatus = `-- name: ListIntegrationsByPartnerServiceAndStatus :many
SELECT organization_id, partner, service, status, info, creation_time, created_by, last_update_time, last_updated_by FROM identity.integration WHERE partner = $1 AND service = $2 AND status = $3 ORDER BY creation_time
`

type ListIntegrationsByPartnerServiceAndStatusParams struct {
	Partner string `db:"partner" json:"partner"`
	Service string `db:"service" json:"service"`
	Status  string `db:"status" json:"status"`
}

func (q *Queries) ListIntegrationsByPartnerServiceAndStatus(ctx context.Context, arg ListIntegrationsByPartnerServiceAndStatusParams) ([]IdentityIntegration, error) {
	rows, err := q.db.QueryContext(ctx, ListIntegrationsByPartnerServiceAndStatus, arg.Partner, arg.Service, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IdentityIntegration{}
	for rows.Next() {
		var i IdentityIntegration
		if err := rows.Scan(
			&i.OrganizationID,
			&i.Partner,
			&i.Service,
			&i.Status,
			&i.Info,
			&i.CreationTime,
			&i.CreatedBy,
			&i.LastUpdateTime,
			&i.LastUpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListIntegrationsByServiceAndStatus = `-- name: ListIntegrationsByServiceAndStatus :many
SELECT organization_id, partner, service, status, info, creation_time, created_by, last_update_time, last_updated_by FROM identity.integration WHERE service = $1 AND status = $2 ORDER BY creation_time
`

type ListIntegrationsByServiceAndStatusParams struct {
	Service string `db:"service" json:"service"`
	Status  string `db:"status" json:"status"`
}

func (q *Queries) ListIntegrationsByServiceAndStatus(ctx context.Context, arg ListIntegrationsByServiceAndStatusParams) ([]IdentityIntegration, error) {
	rows, err := q.db.QueryContext(ctx, ListIntegrationsByServiceAndStatus, arg.Service, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IdentityIntegration{}
	for rows.Next() {
		var i IdentityIntegration
		if err := rows.Scan(
			&i.OrganizationID,
			&i.Partner,
			&i.Service,
			&i.Status,
			&i.Info,
			&i.CreationTime,
			&i.CreatedBy,
			&i.LastUpdateTime,
			&i.LastUpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateIntegrationInfo = `-- name: UpdateIntegrationInfo :one
UPDATE identity.integration SET info = $4, last_update_time = CURRENT_TIMESTAMP
    WHERE organization_id = $1 AND partner = $2 AND service = $3 RETURNING organization_id, partner, service, status, info, creation_time, created_by, last_update_time, last_updated_by
`

type UpdateIntegrationInfoParams struct {
	OrganizationID string          `db:"organization_id" json:"organizationID"`
	Partner        string          `db:"partner" json:"partner"`
	Service        string          `db:"service" json:"service"`
	Info           json.RawMessage `db:"info" json:"info"`
}

func (q *Queries) UpdateIntegrationInfo(ctx context.Context, arg UpdateIntegrationInfoParams) (IdentityIntegration, error) {
	row := q.db.QueryRowContext(ctx, UpdateIntegrationInfo,
		arg.OrganizationID,
		arg.Partner,
		arg.Service,
		arg.Info,
	)
	var i IdentityIntegration
	err := row.Scan(
		&i.OrganizationID,
		&i.Partner,
		&i.Service,
		&i.Status,
		&i.Info,
		&i.CreationTime,
		&i.CreatedBy,
		&i.LastUpdateTime,
		&i.LastUpdatedBy,
	)
	return i, err
}

const UpdateIntegrationStatus = `-- name: UpdateIntegrationStatus :one
UPDATE identity.integration SET status = $4, last_update_time = CURRENT_TIMESTAMP, last_updated_by = $5
    WHERE organization_id = $1 AND partner = $2 AND service = $3 RETURNING organization_id, partner, service, status, info, creation_time, created_by, last_update_time, last_updated_by
`

type UpdateIntegrationStatusParams struct {
	OrganizationID string `db:"organization_id" json:"organizationID"`
	Partner        string `db:"partner" json:"partner"`
	Service        string `db:"service" json:"service"`
	Status         string `db:"status" json:"status"`
	LastUpdatedBy  string `db:"last_updated_by" json:"lastUpdatedBy"`
}

func (q *Queries) UpdateIntegrationStatus(ctx context.Context, arg UpdateIntegrationStatusParams) (IdentityIntegration, error) {
	row := q.db.QueryRowContext(ctx, UpdateIntegrationStatus,
		arg.OrganizationID,
		arg.Partner,
		arg.Service,
		arg.Status,
		arg.LastUpdatedBy,
	)
	var i IdentityIntegration
	err := row.Scan(
		&i.OrganizationID,
		&i.Partner,
		&i.Service,
		&i.Status,
		&i.Info,
		&i.CreationTime,
		&i.CreatedBy,
		&i.LastUpdateTime,
		&i.LastUpdatedBy,
	)
	return i, err
}
