// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: identity_user_organization.sql

package lib

import (
	"context"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const AddUserToOrganization = `-- name: AddUserToOrganization :one
INSERT INTO identity.user_organization AS uo(user_id, organization_id, user_role, allowed_auth_methods)
    VALUES ($1, $2, $3, $4) ON CONFLICT (user_id, organization_id) 
    DO UPDATE 
        SET user_role = $3, allowed_auth_methods = $4, last_update_time = CURRENT_TIMESTAMP WHERE uo.user_id = $1 AND uo.organization_id = $2
    RETURNING user_id, organization_id, user_role, allowed_auth_methods, creation_time, last_update_time
`

type AddUserToOrganizationParams struct {
	UserID             string   `db:"user_id" json:"userID"`
	OrganizationID     string   `db:"organization_id" json:"organizationID"`
	UserRole           string   `db:"user_role" json:"userRole"`
	AllowedAuthMethods []string `db:"allowed_auth_methods" json:"allowedAuthMethods"`
}

func (q *Queries) AddUserToOrganization(ctx context.Context, arg AddUserToOrganizationParams) (IdentityUserOrganization, error) {
	row := q.db.QueryRowContext(ctx, AddUserToOrganization,
		arg.UserID,
		arg.OrganizationID,
		arg.UserRole,
		pq.Array(arg.AllowedAuthMethods),
	)
	var i IdentityUserOrganization
	err := row.Scan(
		&i.UserID,
		&i.OrganizationID,
		&i.UserRole,
		pq.Array(&i.AllowedAuthMethods),
		&i.CreationTime,
		&i.LastUpdateTime,
	)
	return i, err
}

const DeleteAllUsersFromOrganization = `-- name: DeleteAllUsersFromOrganization :exec
DELETE FROM identity.user_organization WHERE organization_id = $1
`

func (q *Queries) DeleteAllUsersFromOrganization(ctx context.Context, organizationID string) error {
	_, err := q.db.ExecContext(ctx, DeleteAllUsersFromOrganization, organizationID)
	return err
}

const DeleteUserFromOrganization = `-- name: DeleteUserFromOrganization :exec
DELETE FROM identity.user_organization WHERE user_id = $1 AND organization_id = $2
`

type DeleteUserFromOrganizationParams struct {
	UserID         string `db:"user_id" json:"userID"`
	OrganizationID string `db:"organization_id" json:"organizationID"`
}

func (q *Queries) DeleteUserFromOrganization(ctx context.Context, arg DeleteUserFromOrganizationParams) error {
	_, err := q.db.ExecContext(ctx, DeleteUserFromOrganization, arg.UserID, arg.OrganizationID)
	return err
}

const GetUserRoleByUserAndOrganization = `-- name: GetUserRoleByUserAndOrganization :one
SELECT user_role FROM identity.user_organization WHERE user_id = $1 AND organization_id = $2
`

type GetUserRoleByUserAndOrganizationParams struct {
	UserID         string `db:"user_id" json:"userID"`
	OrganizationID string `db:"organization_id" json:"organizationID"`
}

func (q *Queries) GetUserRoleByUserAndOrganization(ctx context.Context, arg GetUserRoleByUserAndOrganizationParams) (string, error) {
	row := q.db.QueryRowContext(ctx, GetUserRoleByUserAndOrganization, arg.UserID, arg.OrganizationID)
	var user_role string
	err := row.Scan(&user_role)
	return user_role, err
}

const ListOrganizationsByUser = `-- name: ListOrganizationsByUser :many
SELECT o.id, o.name, o.email_domain, o.website, o.description, o.creation_time, o.status, o.last_update_time, o.allowed_auth_methods, o.created_by, o.auth_id, o.info, uo.user_role, uo.creation_time AS join_organization_time
    FROM identity.user_organization uo INNER JOIN identity.organization o ON uo.organization_id = o.id 
    WHERE uo.user_id = $1 AND o.status = ANY($2::text[])  ORDER BY uo.creation_time
`

type ListOrganizationsByUserParams struct {
	UserID string   `db:"user_id" json:"userID"`
	Status []string `db:"status" json:"status"`
}

type ListOrganizationsByUserRow struct {
	ID                   string          `db:"id" json:"id"`
	Name                 string          `db:"name" json:"name"`
	EmailDomain          string          `db:"email_domain" json:"emailDomain"`
	Website              string          `db:"website" json:"website"`
	Description          string          `db:"description" json:"description"`
	CreationTime         time.Time       `db:"creation_time" json:"creationTime"`
	Status               string          `db:"status" json:"status"`
	LastUpdateTime       time.Time       `db:"last_update_time" json:"lastUpdateTime"`
	AllowedAuthMethods   []string        `db:"allowed_auth_methods" json:"allowedAuthMethods"`
	CreatedBy            string          `db:"created_by" json:"createdBy"`
	AuthID               string          `db:"auth_id" json:"authID"`
	Info                 json.RawMessage `db:"info" json:"info"`
	UserRole             string          `db:"user_role" json:"userRole"`
	JoinOrganizationTime time.Time       `db:"join_organization_time" json:"joinOrganizationTime"`
}

func (q *Queries) ListOrganizationsByUser(ctx context.Context, arg ListOrganizationsByUserParams) ([]ListOrganizationsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, ListOrganizationsByUser, arg.UserID, pq.Array(arg.Status))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrganizationsByUserRow{}
	for rows.Next() {
		var i ListOrganizationsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.EmailDomain,
			&i.Website,
			&i.Description,
			&i.CreationTime,
			&i.Status,
			&i.LastUpdateTime,
			pq.Array(&i.AllowedAuthMethods),
			&i.CreatedBy,
			&i.AuthID,
			&i.Info,
			&i.UserRole,
			&i.JoinOrganizationTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListUsersByOrganization = `-- name: ListUsersByOrganization :many
SELECT u.id, u.first_name, u.last_name, u.email, u.creation_time, u.last_update_time, uo.user_role, uo.creation_time AS join_organization_time
    FROM identity.user_organization uo INNER JOIN identity.user u ON uo.user_id = u.id 
    WHERE uo.organization_id = $1 ORDER BY uo.creation_time
`

type ListUsersByOrganizationRow struct {
	ID                   string    `db:"id" json:"id"`
	FirstName            string    `db:"first_name" json:"firstName"`
	LastName             string    `db:"last_name" json:"lastName"`
	Email                string    `db:"email" json:"email"`
	CreationTime         time.Time `db:"creation_time" json:"creationTime"`
	LastUpdateTime       time.Time `db:"last_update_time" json:"lastUpdateTime"`
	UserRole             string    `db:"user_role" json:"userRole"`
	JoinOrganizationTime time.Time `db:"join_organization_time" json:"joinOrganizationTime"`
}

func (q *Queries) ListUsersByOrganization(ctx context.Context, organizationID string) ([]ListUsersByOrganizationRow, error) {
	rows, err := q.db.QueryContext(ctx, ListUsersByOrganization, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersByOrganizationRow{}
	for rows.Next() {
		var i ListUsersByOrganizationRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.CreationTime,
			&i.LastUpdateTime,
			&i.UserRole,
			&i.JoinOrganizationTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateUserInOrganization = `-- name: UpdateUserInOrganization :one
UPDATE identity.user_organization SET user_role = $3, allowed_auth_methods = $4, last_update_time = CURRENT_TIMESTAMP
    WHERE user_id = $1 AND organization_id = $2 RETURNING user_id, organization_id, user_role, allowed_auth_methods, creation_time, last_update_time
`

type UpdateUserInOrganizationParams struct {
	UserID             string   `db:"user_id" json:"userID"`
	OrganizationID     string   `db:"organization_id" json:"organizationID"`
	UserRole           string   `db:"user_role" json:"userRole"`
	AllowedAuthMethods []string `db:"allowed_auth_methods" json:"allowedAuthMethods"`
}

func (q *Queries) UpdateUserInOrganization(ctx context.Context, arg UpdateUserInOrganizationParams) (IdentityUserOrganization, error) {
	row := q.db.QueryRowContext(ctx, UpdateUserInOrganization,
		arg.UserID,
		arg.OrganizationID,
		arg.UserRole,
		pq.Array(arg.AllowedAuthMethods),
	)
	var i IdentityUserOrganization
	err := row.Scan(
		&i.UserID,
		&i.OrganizationID,
		&i.UserRole,
		pq.Array(&i.AllowedAuthMethods),
		&i.CreationTime,
		&i.LastUpdateTime,
	)
	return i, err
}
