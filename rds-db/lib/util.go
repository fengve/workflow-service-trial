// This code file is NOT auto generated by sqlc.
// You may edit it.

package lib

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"os"
	"regexp"
	"strings"

	"github.com/XSAM/otelsql"
	"github.com/docker/go-connections/nat"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/wait"
)

type SqlDbConfig struct {
	HostName string `json:"hostName"`
	HostPort string `json:"hostPort"`
	UserName string `json:"userName"`
	Password string `json:"password"`
	DbName   string `json:"dbName"`
}

const (
	TEST_POSTGRES_DB_NAME       = "postgres"
	TEST_POSTGRES_USERNAME      = "rds_db_admin"
	TEST_POSTGRES_PASSWORD      = "password"
	TEST_POSTGRES_PORT          = "5432/tcp"
	TEST_POSTGRES_DB_URL_FORMAT = "postgres://%s:%s@localhost:%s/%s?sslmode=disable"
)

// sqlDDLAndDMLPattern is a regex pattern to match SQL write operations.
const sqlDDLAndDMLPattern = `(?i)(insert\s+into|update|delete\s+from|create\s+table|create\s+index|create\s+view|create\s+schema|alter\s+table|drop\s+table|drop\s+index|drop\s+view|drop\s+schema|truncate\s+table|copy\s+\w+\s+from|rename\s+table)\s+`

var sqlDDLDMLRegex = regexp.MustCompile(sqlDDLAndDMLPattern)

func CreateTestContainerForPostgresDb(ctx context.Context, packageName string) (testcontainers.Container, *sql.DB, error) {
	var env = map[string]string{
		"POSTGRES_DB":       TEST_POSTGRES_DB_NAME,
		"POSTGRES_USER":     TEST_POSTGRES_USERNAME,
		"POSTGRES_PASSWORD": TEST_POSTGRES_PASSWORD,
	}
	// Work out the path to the test_db_init.sql and set mount strings
	workingDir, _ := os.Getwd()
	rootDir := strings.Replace(workingDir, packageName, "", 1)
	mountFrom := fmt.Sprintf("%s/rds-db/db/schema.sql", rootDir)
	mountTo := "/docker-entrypoint-initdb.d/init.sql"

	dbUrlFunc := func(_ string, port nat.Port) string {
		return fmt.Sprintf(TEST_POSTGRES_DB_URL_FORMAT, TEST_POSTGRES_USERNAME, TEST_POSTGRES_PASSWORD, port.Port(), TEST_POSTGRES_DB_NAME)
	}
	genericRequest := testcontainers.GenericContainerRequest{
		ContainerRequest: testcontainers.ContainerRequest{
			Image:        "postgres:13",
			ExposedPorts: []string{TEST_POSTGRES_PORT},
			Mounts: []testcontainers.ContainerMount{
				testcontainers.BindMount(mountFrom, testcontainers.ContainerMountTarget(mountTo)),
			},
			Env:        env,
			WaitingFor: wait.ForSQL(nat.Port(TEST_POSTGRES_PORT), "postgres", dbUrlFunc),
		},
		Started: true,
	}
	container, err := testcontainers.GenericContainer(ctx, genericRequest)
	if err != nil {
		return container, nil, fmt.Errorf("failed to start container: %s", err)
	}
	mappedPort, err := container.MappedPort(ctx, nat.Port(TEST_POSTGRES_PORT))
	if err != nil {
		return container, nil, fmt.Errorf("failed to get container external port: %s", err)
	}
	dbUrl := dbUrlFunc("", mappedPort)
	db, err := sql.Open("postgres", dbUrl)
	if err != nil {
		return container, db, fmt.Errorf("failed to establish database connection: %s", err)
	}

	return container, db, nil
}

func ConnectSqlDb(driverName string, config SqlDbConfig) (*sql.DB, error) {
	dataSourceName := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
		config.HostName, config.HostPort, config.UserName, config.Password, config.DbName)
	db, err := otelsql.Open(driverName, dataSourceName)
	if err != nil {
		return nil, err
	}
	// Ping DB to verify the connection.
	err = db.Ping()
	if err != nil {
		return nil, err
	}

	return db, nil
}

// Create a SQL Transaction & Queries who wraps this transaction.
func (q *Queries) BeginTx(ctx context.Context) (*Queries, *sql.Tx, error) {
	if sqlDb, ok := q.db.(*sql.DB); ok {
		tx, err := sqlDb.BeginTx(ctx, nil)
		if err != nil {
			return nil, nil, err
		}
		return &Queries{db: tx}, tx, nil
	}
	return nil, nil, errors.New("failed to convert DBTX to type sql.DB")
}

// Create a SQL Transaction (with the strictest transaction isolation level: Serializable) & Queries who wraps this transaction.
func (q *Queries) BeginSerializableTx(ctx context.Context) (*Queries, *sql.Tx, error) {
	if sqlDb, ok := q.db.(*sql.DB); ok {
		txOptions := &sql.TxOptions{
			Isolation: sql.LevelSerializable,
		}
		tx, err := sqlDb.BeginTx(ctx, txOptions)
		if err != nil {
			return nil, nil, err
		}
		return &Queries{db: tx}, tx, nil
	}
	return nil, nil, errors.New("failed to convert DBTX to type sql.DB")
}

// Query multiple rows with the given query and args.
func (q *Queries) QueryRowsWithCustomQuery(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
	return q.db.QueryContext(ctx, query, args...)
}

func (q *Queries) QueryRowWithCustomQuery(ctx context.Context, query string, args ...interface{}) *sql.Row {
	return q.db.QueryRowContext(ctx, query, args...)
}

// NewReadOnlyDBForTest returns a read-only version of the DB for testing.
func NewReadOnlyDBForTest(db DBTX) *Queries {
	return &Queries{db: newReadOnlyDB(db)}
}

// NewReadOnlyDB returns a read-only version of the DB.
func newReadOnlyDB(db DBTX) DBTX {
	return &ReadOnlyDB{DB: db}
}

// ReadOnlyDB is a wrapper for sql.DB to prevent write operations.
type ReadOnlyDB struct {
	DB DBTX
}

func (d *ReadOnlyDB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
	panic(fmt.Sprintf("Try to execute write operation on read-only database with query: %s args:%v", query, args))
}

func (d *ReadOnlyDB) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) {
	if IsSqlDMLOrDDL(query) {
		panic(fmt.Sprintf("Try to prepare statement on read-only database with query:%s", query))
	}
	return d.DB.PrepareContext(ctx, query)
}

func (d *ReadOnlyDB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
	if IsSqlDMLOrDDL(query) {
		panic(fmt.Sprintf("Try to execute write operation on read-only database with query: %s args:%v", query, args))
	}
	return d.DB.QueryContext(ctx, query, args...)
}

func (d *ReadOnlyDB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row {
	if IsSqlDMLOrDDL(query) {
		panic(fmt.Sprintf("Try to execute write operation on read-only database with query: %s args:%v", query, args))
	}
	return d.DB.QueryRowContext(ctx, query, args...)
}

// IsSqlDMLOrDDL checks if the given SQL statement is a DML or DDL statement.
func IsSqlDMLOrDDL(sql string) bool {
	return sqlDDLDMLRegex.MatchString(sql)
}
